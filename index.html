<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>$PFP-MAN Game</title>
    <link rel="icon" type="image/png" href="pfp.png">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* Retro Game Aesthetics */
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            /* CUSTOM BACKGROUND IMAGE */
            background-image: url('https://pbs.twimg.com/media/G2pl8OeW0AAEgIS?format=jpg&name=large');
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            background-color: #000;
            font-family: 'Press Start 2P', cursive;
            color: #fff;
            flex-direction: column;
            padding: 20px;
        }

        #game-container {
            border: 10px solid #333;
            border-radius: 15px;
            box-shadow: 0 0 40px rgba(255, 255, 0, 0.5), 0 0 15px #fff;
            background-color: #000000e0; /* Semi-transparent black over the background image */
        }

        canvas {
            display: block;
            background-color: #000000;
        }

        #game-info {
            width: 100%;
            max-width: 960px; /* Adjusted max width for larger map (24*40 = 960) */
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            font-size: 20px;
            color: #ffcc00; /* Yellow */
            text-shadow: 3px 3px 0 #000;
        }

        #info-score, #info-lives {
            background-color: #111;
            padding: 10px 20px;
            border-radius: 8px;
            border: 3px solid #ffcc00;
            box-shadow: inset 0 0 8px rgba(255, 255, 0, 0.7);
        }

        h1 {
            color: #ff0;
            text-align: center;
            margin-bottom: 20px;
            font-size: 36px;
            text-shadow: 5px 5px 0 #ff6600;
        }
        
        /* Message Box Styling */
        #message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.95);
            border: 6px solid #ff0;
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            z-index: 1000;
            box-shadow: 0 0 60px rgba(255, 255, 0, 0.9);
            display: none; /* Hidden by default */
        }
        #message-box p {
            font-size: 22px;
            margin-bottom: 25px;
        }
        .pacman-icon {
            color: #ff0;
            font-size: 40px;
            margin-bottom: 15px;
        }
    </style>
</head>
<body>

    <!-- A log√≥ elt√°vol√≠tva a c√≠m mell≈ël, csak a sz√∂veg maradt -->
    <h1 class="title-bar">$PFP-MAN</h1>

    <div id="game-info">
        <div id="info-score">SCORE: 0</div>
        <div id="info-lives">LIVES: 3</div>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
    </div>

    <div id="message-box">
        <div class="pacman-icon">üü°</div>
        <p id="message-text">Press ENTER to Start</p>
        <p style="font-size: 12px; color: #aaa;">Use Arrow Keys for Movement</p>
    </div>

    <script>
        // --- CONSTANTS AND CONFIGURATION ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // P√°lya m√©ret√©nek n√∂vel√©se: TILE_SIZE 35-r≈ël 40-re
        const TILE_SIZE = 40; 
        const MAP_ROWS = 24;
        const MAP_COLS = 24;
        
        // --- SEBESS√âG √ÅLLAND√ìK (A sebess√©gek cs√∂kkentve lettek) ---
        // A mozg√°s a Delta Time-mal lesz szorozva, √≠gy a konstansok a 60 FPS-es sebess√©get jelentik
        const PAC_SPEED = 3.0; // Eredeti: 4.0
        const GHOST_BASE_SPEED = 2.4; // Eredeti: 3.2
        const GHOST_FRIGHT_SPEED = 1.5; // Eredeti: 2.0
        const GHOST_DEAD_SPEED = 6.0; // Eredeti: 8.0

        const DOT_RADIUS = 4; 
        const POWER_PELLET_RADIUS = 8; 
        const POWER_PELLET_DURATION = 8000; // 8 seconds
        const GHOST_FRIGHT_COLOR = 'blue';
        
        // PFP-MAN k√©p be√°ll√≠t√°sa
        // FONTOS: CSER√âLD KI EZT AZ URL-T A SAJ√ÅT PFP.PNG EL√âR√âSI √öTJ√ÅRA!
        const PFP_IMAGE_URL = 'pfp.png'; 
        const pfpImage = new Image();
        pfpImage.src = PFP_IMAGE_URL; 

        // Canvas m√©ret be√°ll√≠t√°sa
        canvas.width = MAP_COLS * TILE_SIZE;
        canvas.height = MAP_ROWS * TILE_SIZE;

        // --- GAME STATE VARIABLES ---
        let score = 0;
        let lives = 3;
        let level = 1;
        let gameLoopId;
        let isPaused = true;
        let lastUpdateTime = 0; // Delta Time sz√°m√≠t√°s√°hoz
        let powerPelletTimer = 0;
        const FPS_RATE = 1000 / 60; // 16.666 ms, 60 FPS alap√©rt√©k

        // 0: Dot, 1: Wall, 2: Empty, 3: Ghost Gate, 4: Power Pellet
        let initialMap = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,4,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,4,1],
            [1,0,1,1,1,0,1,1,1,1,0,1,1,0,1,1,1,1,0,1,1,1,0,1],
            [1,0,1,1,1,0,1,1,1,1,0,1,1,0,1,1,1,1,0,1,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,0,1],
            [1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1],
            [1,1,1,1,0,1,1,1,1,1,2,2,2,2,1,1,1,1,1,0,1,1,1,1], 
            [1,1,1,1,0,1,1,0,0,0,3,3,3,3,0,0,0,1,1,0,1,1,1,1], // Szellem h√°z
            [1,1,1,1,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,1,1,1,1],
            [1,0,0,0,0,1,1,0,1,1,2,2,2,2,1,1,0,1,1,0,0,0,0,1],
            [1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1],
            [1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,1],
            [1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,1],
            [1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,1,1],
            [1,0,0,0,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,0,0,0,1],
            [1,4,1,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,4,1],
            [1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,1,0,1,1,1,1,0,1,1,0,1,1,1,1,0,1,1,1,0,1],
            [1,0,1,1,1,0,1,1,1,1,0,1,1,0,1,1,1,1,0,1,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];
        
        let map = initialMap.map(row => [...row]);

        // --- PAC-MAN OBJECT ---
        const pacman = {
            x: 1 * TILE_SIZE + TILE_SIZE / 2,
            y: 1 * TILE_SIZE + TILE_SIZE / 2,
            // Karakter m√©ret√©nek n√∂vel√©se a nagyobb TILE_SIZE-hoz igaz√≠tva
            radius: TILE_SIZE / 2.2, 
            dirX: PAC_SPEED,
            dirY: 0,
            nextDirX: PAC_SPEED,
            nextDirY: 0,
            color: 'yellow',
        };

        // --- GHOST CLASS ---
        class Ghost {
            constructor(startX, startY, color, name) {
                this.startX = startX;
                this.startY = startY;
                this.x = startX;
                this.y = startY;
                this.color = color;
                this.name = name;
                this.dirX = 0;
                this.dirY = -GHOST_BASE_SPEED;
                this.isFrightened = false;
                this.isDead = false;
                this.speed = GHOST_BASE_SPEED;
                this.radius = TILE_SIZE / 2.5; 
            }

            getCurrentSpeed() {
                if (this.isDead) return GHOST_DEAD_SPEED;
                if (this.isFrightened) return GHOST_FRIGHT_SPEED;
                return GHOST_BASE_SPEED;
            }

            // Fal ellen≈ërz√©s a szellemek sz√°m√°ra
            checkWall(x, y) {
                const tileY = Math.floor(y);
                const tileX = Math.floor(x);

                if (tileY < 0 || tileY >= MAP_ROWS || tileX < 0 || tileX >= MAP_COLS) {
                    return true; 
                }

                const tileType = map[tileY][tileX];
                // A szellemeket csak a Wall (1) blokkolja. √Åtmehetnek a Ghost Gate (3) alatt
                return tileType === 1;
            }

            snapToCenter(tileX, tileY) {
                 this.x = tileX * TILE_SIZE + TILE_SIZE / 2;
                 this.y = tileY * TILE_SIZE + TILE_SIZE / 2;
            }
            
            shouldChangeDirection(speedFactor) {
                const speed = this.getCurrentSpeed() * speedFactor;
                const currentTileX = Math.floor(this.x / TILE_SIZE);
                const currentTileY = Math.floor(this.y / TILE_SIZE);

                // Megn√∂velt tolerancia a stabilit√°s √©rdek√©ben
                const centerTolerance = TILE_SIZE * 0.1; 

                // Szellemnek a csempe k√∂zep√©n kell lennie a d√∂nt√©shez
                const isCenteredX = Math.abs((this.x % TILE_SIZE) - TILE_SIZE / 2) < centerTolerance;
                const isCenteredY = Math.abs((this.y % TILE_SIZE) - TILE_SIZE / 2) < centerTolerance;

                // Ha el√∂l fal van, vagy el√°gaz√°sban van, v√°ltoztatnia kell az ir√°nyt
                const nextTileX = currentTileX + (this.dirX > 0 ? 1 : this.dirX < 0 ? -1 : 0);
                const nextTileY = currentTileY + (this.dirY > 0 ? 1 : this.dirY < 0 ? -1 : 0);
                const isWallAhead = this.checkWall(nextTileX, nextTileY);

                if (isWallAhead) {
                    this.snapToCenter(currentTileX, currentTileY);
                    return true;
                }
                
                // Ha a k√∂zep√©n van, ellen≈ërizze, hogy el√°gaz√°sban van-e
                if (isCenteredX && isCenteredY) {
                    const possibleDirections = this.getPossibleDirections(currentTileX, currentTileY);
                    // Ha egyn√©l t√∂bb √©rv√©nyes mozg√°s van (nem folyos√≥), d√∂nteni kell
                    if (possibleDirections.length >= 2) { 
                        return true;
                    }
                }

                return false;
            }

            getPossibleDirections(tileX, tileY) {
                const possibleMoves = [];
                const directions = [
                    { dx: 1, dy: 0 },
                    { dx: -1, dy: 0 },
                    { dx: 0, dy: 1 },
                    { dx: 0, dy: -1 }
                ];

                for (const dir of directions) {
                    const nextTileX = tileX + dir.dx;
                    const nextTileY = tileY + dir.dy;
                    
                    const isBlocked = this.checkWall(nextTileX, nextTileY);
                    // Ne forduljon vissza azonnal, kiv√©ve, ha zs√°kutca van
                    const isReverse = (dir.dx === -Math.sign(this.dirX) && dir.dy === -Math.sign(this.dirY));

                    if (!isBlocked && !isReverse) {
                        possibleMoves.push(dir);
                    }
                }
                
                // Zs√°kutca eset√©n visszafordul
                if (possibleMoves.length === 0) {
                     possibleMoves.push({ dx: -Math.sign(this.dirX), dy: -Math.sign(this.dirY) });
                }
                return possibleMoves;
            }

            chooseBestMove(moves, currentTileX, currentTileY, targetX, targetY) {
                let bestMove = moves[0];
                let bestDistance = this.isFrightened ? -Infinity : Infinity; 

                for (const move of moves) {
                    const newX = currentTileX + move.dx;
                    const newY = currentTileY + move.dy;

                    const distance = Math.hypot(newX - targetX, newY - targetY);

                    if (this.isFrightened) {
                        // R√©m√ºlt: T√ÅVOLODJON a c√©lpontt√≥l (maximaliz√°lja a t√°vols√°got)
                        if (distance > bestDistance) {
                            bestDistance = distance;
                            bestMove = move;
                        }
                    } else {
                        // √úld√∂z√©s/Halott: K√∂zeledjen a c√©lponthoz (minimaliz√°lja a t√°vols√°got)
                        if (distance < bestDistance) {
                            bestDistance = distance;
                            bestMove = move;
                        }
                    }
                }
                return bestMove;
            }

            // F≈ë friss√≠t√©si ciklus
            update(speedFactor) {
                this.speed = this.getCurrentSpeed();

                const currentTileX = Math.floor(this.x / TILE_SIZE);
                const currentTileY = Math.floor(this.y / TILE_SIZE);

                let targetTileX, targetTileY;

                if (this.isDead) {
                    // C√©l: Szellem kezd≈ë poz√≠ci√≥ (hazat√©r√©s)
                    targetTileX = Math.floor(this.startX / TILE_SIZE);
                    targetTileY = Math.floor(this.startY / TILE_SIZE);

                    if (currentTileX === targetTileX && currentTileY === targetTileY) {
                        this.isDead = false;
                        this.isFrightened = false;
                        this.dirX = 0;
                        this.dirY = -GHOST_BASE_SPEED; 
                        this.snapToCenter(currentTileX, currentTileY);
                        return;
                    }

                } else {
                    // C√©l: Pacman poz√≠ci√≥ja
                    targetTileX = Math.floor(pacman.x / TILE_SIZE);
                    targetTileY = Math.floor(pacman.y / TILE_SIZE);
                }
                
                // Ha ir√°nyt kell v√°ltani
                if (this.shouldChangeDirection(speedFactor)) {
                    const possibleMoves = this.getPossibleDirections(currentTileX, currentTileY);
                    
                    if (possibleMoves.length > 0) {
                        const bestMove = this.chooseBestMove(possibleMoves, currentTileX, currentTileY, targetTileX, targetTileY);
                        // Be√°ll√≠tja a sebess√©get az √∫j ir√°nyba, a speed konstanssal szorozva.
                        this.dirX = bestMove.dx * this.speed;
                        this.dirY = bestMove.dy * this.speed;
                    } else {
                        this.dirX = 0;
                        this.dirY = 0;
                    }
                }
                
                // Mozg√°s a delta time alapj√°n sk√°l√°zva
                this.x += this.dirX * speedFactor;
                this.y += this.dirY * speedFactor;
            }

            draw() {
                // Szellem rajzol√°sa... (Nem v√°ltozott)
                // Ghost body 
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);

                if (this.isDead) {
                    ctx.fillStyle = 'white';
                } else if (this.isFrightened) {
                    const flashDuration = 2000;
                    if (powerPelletTimer < flashDuration && (Math.floor(Date.now() / 200) % 2) === 0) {
                        ctx.fillStyle = 'white'; 
                    } else {
                        ctx.fillStyle = GHOST_FRIGHT_COLOR; 
                    }
                } else {
                    ctx.fillStyle = this.color;
                }
                ctx.fill();
                ctx.closePath();

                // Draw eyes (always white with black pupils)
                const eyeSize = TILE_SIZE / 7;
                const pupilSize = TILE_SIZE / 14;
                const eyeOffset = TILE_SIZE / 5;

                // A szem ir√°ny√°t a normaliz√°lt dirX/dirY alapj√°n kell kisz√°molni
                const speed = this.getCurrentSpeed();
                let eyeDirX = this.dirX / speed / (this.dirX !== 0 ? 1 : this.dirY !== 0 ? 1 : 1) || 0;
                let eyeDirY = this.dirY / speed / (this.dirY !== 0 ? 1 : this.dirX !== 0 ? 1 : 1) || 0;
                
                if (this.isDead) {
                    eyeDirX = 0;
                    eyeDirY = -1;
                }
                
                // Left Eye
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(this.x - eyeOffset, this.y - eyeOffset, eyeSize, 0, Math.PI * 2);
                ctx.fill();

                // Right Eye
                ctx.beginPath();
                ctx.arc(this.x + eyeOffset, this.y - eyeOffset, eyeSize, 0, Math.PI * 2);
                ctx.fill();

                // Pupils
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(this.x - eyeOffset + eyeDirX * (eyeSize - pupilSize), this.y - eyeOffset + eyeDirY * (eyeSize - pupilSize), pupilSize, 0, Math.PI * 2);
                ctx.fill();

                ctx.beginPath();
                ctx.arc(this.x + eyeOffset + eyeDirX * (eyeSize - pupilSize), this.y + eyeDirY * (eyeSize - pupilSize) - eyeOffset, pupilSize, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        const ghosts = [
            new Ghost(9 * TILE_SIZE + TILE_SIZE / 2, 9 * TILE_SIZE + TILE_SIZE / 2, 'lime', 'Ghost5'), 
            new Ghost(10 * TILE_SIZE + TILE_SIZE / 2, 9 * TILE_SIZE + TILE_SIZE / 2, 'red', 'Blinky'),
            new Ghost(11 * TILE_SIZE + TILE_SIZE / 2, 9 * TILE_SIZE + TILE_SIZE / 2, 'pink', 'Pinky'),
            new Ghost(12 * TILE_SIZE + TILE_SIZE / 2, 9 * TILE_SIZE + TILE_SIZE / 2, 'cyan', 'Inky'),
            new Ghost(13 * TILE_SIZE + TILE_SIZE / 2, 9 * TILE_SIZE + TILE_SIZE / 2, 'orange', 'Clyde'),
        ];

        // --- DRAWING FUNCTIONS ---

        function drawMap() {
             for (let y = 0; y < MAP_ROWS; y++) {
                for (let x = 0; x < MAP_COLS; x++) {
                    const type = map[y][x];
                    const centerX = x * TILE_SIZE + TILE_SIZE / 2;
                    const centerY = y * TILE_SIZE + TILE_SIZE / 2;

                    if (type === 1) { // Fal (Wall)
                        ctx.fillStyle = '#0000FF'; // K√©k falak
                        ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                        
                        // K√©k keret
                        ctx.strokeStyle = '#3333FF';
                        ctx.lineWidth = 4;
                        ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);

                    } else if (type === 3) { // Szellem kapu (Ghost Gate)
                        ctx.fillStyle = '#ff66b2'; // R√≥zsasz√≠n kapu vonal
                        ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE + TILE_SIZE/3, TILE_SIZE, TILE_SIZE/4);
                    }
                     else if (type === 0) { // Pont (Dot)
                        ctx.fillStyle = 'white';
                        ctx.beginPath();
                        const scale = 1 + Math.sin(Date.now() / 400) * 0.05; 
                        ctx.arc(centerX, centerY, DOT_RADIUS * scale, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (type === 4) { // Er≈ë pellet (Power Pellet)
                        ctx.fillStyle = 'white';
                        ctx.beginPath();
                        const scale = 1 + Math.sin(Date.now() / 200) * 0.2;
                        ctx.arc(centerX, centerY, POWER_PELLET_RADIUS * scale, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
        }

        function drawPacman() {
            ctx.save();
            
            ctx.translate(pacman.x, pacman.y);

            let rotationAngle = 0;
            // A forgat√°si sz√∂get az aktu√°lis vagy a k√∂vetkez≈ë ir√°ny hat√°rozza meg
            let currentDirX = pacman.dirX || pacman.nextDirX;
            let currentDirY = pacman.dirY || pacman.nextDirY;

            if (currentDirX > 0) rotationAngle = 0; 
            else if (currentDirX < 0) rotationAngle = Math.PI; 
            else if (currentDirY < 0) rotationAngle = -Math.PI / 2; 
            else if (currentDirY > 0) rotationAngle = Math.PI / 2; 
            
            ctx.rotate(rotationAngle);
            
            // A karakter m√©rete a megn√∂velt pacman.radius alapj√°n
            const size = pacman.radius * 2;
            
            if (pfpImage.complete) {
                // PFP k√©p rajzol√°sa
                ctx.drawImage(pfpImage, -size / 2, -size / 2, size, size);
            } else {
                // Visszaes√©s s√°rga k√∂rre
                ctx.fillStyle = pacman.color;
                ctx.beginPath();
                ctx.arc(0, 0, pacman.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.closePath();
            }

            ctx.restore();
        }

        function drawHUD() {
            document.getElementById('info-score').textContent = `SCORE: ${score}`;
            document.getElementById('info-lives').textContent = `LIVES: ${lives}`;
        }

        // --- J√ÅT√âK LOGIKA FUNKCI√ìK ---

        function checkNextDirection() {
            // A sebess√©g a PAC_SPEED √©rt√©k√©t haszn√°lja (a sebess√©get a gameLoop sk√°l√°zza a delta time-mal)
            const speed = PAC_SPEED; 

            // A k√∂vetkez≈ë ir√°nyban l√©v≈ë csempe
            const nextTileX = Math.floor((pacman.x + (Math.sign(pacman.nextDirX) * speed * 0.5)) / TILE_SIZE);
            const nextTileY = Math.floor((pacman.y + (Math.sign(pacman.nextDirY) * speed * 0.5)) / TILE_SIZE);

            // Pac-Man falak √©s szellemkapu √°ltal blokkolva van (1 vagy 3)
            const isTargetWall = (
                nextTileY < 0 || nextTileY >= MAP_ROWS || nextTileX < 0 || nextTileX >= MAP_COLS || 
                (map[nextTileY] && (map[nextTileY][nextTileX] === 1 || map[nextTileY][nextTileX] === 3))
            );

            if (isTargetWall) {
                return; 
            }
            
            // Szigor√∫ tolerancia a pontos kanyarhoz
            const centerTolerance = 2.0; 
            
            let shouldTurn = false;

            if (pacman.dirX !== 0 && pacman.nextDirY !== 0) { // V√≠zszintesr≈ël f√ºgg≈ëlegesre
                // Ellen≈ërzi, hogy a Y koordin√°ta a csempe k√∂zep√©n van-e
                const isAlignedVertically = Math.abs((pacman.y % TILE_SIZE) - TILE_SIZE / 2) < centerTolerance;
                if (isAlignedVertically) {
                    shouldTurn = true;
                    // CS√öSZ√ÅS FIX: X koordin√°ta k√∂zpontos√≠t√°sa a f√ºgg≈ëleges mozg√°s megkezd√©se el≈ëtt
                    pacman.x = Math.floor(pacman.x / TILE_SIZE) * TILE_SIZE + TILE_SIZE / 2;
                }
            } 
            else if (pacman.dirY !== 0 && pacman.nextDirX !== 0) { // F√ºgg≈ëlegesr≈ël v√≠zszintesre
                // Ellen≈ërzi, hogy az X koordin√°ta a csempe k√∂zep√©n van-e
                const isAlignedHorizontally = Math.abs((pacman.x % TILE_SIZE) - TILE_SIZE / 2) < centerTolerance;
                if (isAlignedHorizontally) {
                    shouldTurn = true;
                    // CS√öSZ√ÅS FIX: Y koordin√°ta k√∂zpontos√≠t√°sa a v√≠zszintes mozg√°s megkezd√©se el≈ëtt
                    pacman.y = Math.floor(pacman.y / TILE_SIZE) * TILE_SIZE + TILE_SIZE / 2;
                }
            }
            else if (pacman.dirX === 0 && pacman.dirY === 0) {
                 shouldTurn = true; // Kezdeti mozg√°s
            }

            if (shouldTurn) {
                pacman.dirX = pacman.nextDirX;
                pacman.dirY = pacman.nextDirY;
            }
        }

        function movePacman(speedFactor) {
            // Sk√°l√°zott mozg√°s a Delta Time-mal
            const moveX = pacman.dirX * speedFactor;
            const moveY = pacman.dirY * speedFactor;
            
            const nextX = pacman.x + moveX;
            const nextY = pacman.y + moveY;

            // CS√öSZ√ÅS FIX: √útk√∂z√©sellen≈ërz√©s a k√∂vetkez≈ë poz√≠ci√≥ban
            const nextTileX = Math.floor(nextX / TILE_SIZE);
            const nextTileY = Math.floor(nextY / TILE_SIZE);

            const isTargetWall = (
                nextTileY < 0 || nextTileY >= MAP_ROWS || nextTileX < 0 || nextTileX >= MAP_COLS || 
                (map[nextTileY] && (map[nextTileY][nextTileX] === 1 || map[nextTileY][nextTileX] === 3))
            );

            if (isTargetWall) { 
                // Ha falba √ºtk√∂zik, √°ll√≠tsa le a mozg√°st
                pacman.dirX = 0;
                pacman.dirY = 0;
                pacman.nextDirX = 0;
                pacman.nextDirY = 0;
                
                // Extra biztons√°gi ellen≈ërz√©s: ha Pacman t√∫ls√°gosan a falban van,
                // be kell pattannia a jelenlegi csempe k√∂zep√©re.
                const currentTileX = Math.floor(pacman.x / TILE_SIZE);
                const currentTileY = Math.floor(pacman.y / TILE_SIZE);

                // Megn√©zz√ºk, hogy melyik ir√°nyba volt a mozg√°s, √©s csak azt az oldalt igaz√≠tjuk.
                if (Math.sign(moveX) !== 0) {
                    pacman.x = currentTileX * TILE_SIZE + TILE_SIZE / 2;
                }
                if (Math.sign(moveY) !== 0) {
                    pacman.y = currentTileY * TILE_SIZE + TILE_SIZE / 2;
                }

            } else {
                pacman.x = nextX;
                pacman.y = nextY;
            }

            // Csempe √ºtk√∂z√©s (pontok/pelletek ev√©se)
            const currentTileX = Math.floor(pacman.x / TILE_SIZE);
            const currentTileY = Math.floor(pacman.y / TILE_SIZE);
            
            // Biztons√°gos hozz√°f√©r√©s a t√©rk√©phez
            if (currentTileY >= 0 && currentTileY < MAP_ROWS && currentTileX >= 0 && currentTileX < MAP_COLS) {
                const tileType = map[currentTileY][currentTileX];

                if (tileType === 0) { // Pont
                    map[currentTileY][currentTileX] = 2; // √úres
                    score += 10;
                } else if (tileType === 4) { // Er≈ë Pellet
                    map[currentTileY][currentTileX] = 2; // √úres
                    score += 50;
                    startFrightMode();
                }
            }

            // Szint teljes√≠t√©s√©nek ellen≈ërz√©se
            if (countRemainingDots() === 0) {
                levelComplete();
            }
        }

        function startFrightMode() {
            powerPelletTimer = POWER_PELLET_DURATION;
            ghosts.forEach(g => {
                if (!g.isDead) {
                    g.isFrightened = true;
                    // Ir√°nyv√°lt√°s
                    g.dirX = -g.dirX;
                    g.dirY = -g.dirY;
                }
            });
        }

        function updateFrightMode(deltaTime) {
            if (powerPelletTimer > 0) {
                powerPelletTimer -= deltaTime; // Id≈ëalap√∫ id≈ëz√≠t≈ë friss√≠t√©s
                if (powerPelletTimer <= 0) {
                    powerPelletTimer = 0;
                    ghosts.forEach(g => g.isFrightened = false);
                }
            }
        }

        function checkGhostCollision() {
            for (const ghost of ghosts) {
                const dist = Math.hypot(pacman.x - ghost.x, pacman.y - ghost.y);

                if (dist < pacman.radius + ghost.radius) {
                    if (ghost.isFrightened) {
                        score += 200;
                        ghost.isDead = true;
                        ghost.isFrightened = false;
                        showMessage('GHOST EATEN!', 1500);
                    } else if (!ghost.isDead) {
                        resetPacman();
                        lives--;
                        if (lives <= 0) {
                            gameOver();
                        } else {
                            showMessage('OUCH!', 1500);
                        }
                    }
                }
            }
        }

        function countRemainingDots() {
            let dots = 0;
            for (let y = 0; y < MAP_ROWS; y++) {
                for (let x = 0; x < MAP_COLS; x++) {
                    if (map[y][x] === 0 || map[y][x] === 4) {
                        dots++;
                    }
                }
            }
            return dots;
        }

        function levelComplete() {
            isPaused = true;
            level++;
            showMessage(`LEVEL ${level - 1} COMPLETE!`, 3000, () => {
                 resetGame(true);
                 showMessage('GET READY!', 1500, () => { isPaused = false; });
            });
        }

        function gameOver() {
            isPaused = true;
            showMessage('GAME OVER', Infinity, () => {
                document.addEventListener('keydown', handleRestart);
            });
        }

        function handleRestart(e) {
            if (e.key === 'Enter') {
                document.removeEventListener('keydown', handleRestart);
                resetGame(false);
                score = 0;
                lives = 3;
                level = 1;
                isPaused = false;
                hideMessage();
            }
        }

        function resetPacman() {
            pacman.x = 1 * TILE_SIZE + TILE_SIZE / 2;
            pacman.y = 1 * TILE_SIZE + TILE_SIZE / 2;
            pacman.dirX = PAC_SPEED;
            pacman.dirY = 0;
            pacman.nextDirX = PAC_SPEED;
            pacman.nextDirY = 0;
            ghosts.forEach(g => {
                g.x = g.startX;
                g.y = g.startY;
                g.isFrightened = false;
                g.isDead = false;
                g.dirX = 0;
                g.dirY = -GHOST_BASE_SPEED; 
            });
        }

        function resetGame(keepDots) {
            resetPacman();
            powerPelletTimer = 0;

            if (!keepDots) {
                 map = initialMap.map(row => [...row]);
            }
        }

        function showMessage(text, duration = Infinity, callback = () => {}) {
            const messageBox = document.getElementById('message-box');
            document.getElementById('message-text').textContent = text;
            messageBox.style.display = 'block';

            if (duration !== Infinity) {
                setTimeout(() => {
                    hideMessage();
                    callback();
                }, duration);
            }
        }

        function hideMessage() {
            document.getElementById('message-box').style.display = 'none';
        }

        // --- J√ÅT√âK CIKLUS (Delta Time haszn√°lat√°val) ---

        function gameLoop(timestamp) {
            // Delta Time (eltelt id≈ë az el≈ëz≈ë k√©pkocka √≥ta)
            const deltaTime = timestamp - (lastUpdateTime || timestamp); 
            // Sebess√©gi t√©nyez≈ë: normaliz√°lja a mozg√°st a 60 FPS-hez
            const speedFactor = deltaTime / FPS_RATE; 

            if (!isPaused) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // 1. Friss√≠t√©s (Delta Time-ot haszn√°lva)
                checkNextDirection();
                movePacman(speedFactor); // Mozg√°s Delta Time-mal
                updateFrightMode(deltaTime); // Id≈ëz√≠t≈ë Delta Time-mal
                ghosts.forEach(g => g.update(speedFactor)); // Szellemek mozg√°sa Delta Time-mal
                checkGhostCollision();

                // 2. Rajzol√°s
                drawMap();
                drawPacman();
                ghosts.forEach(g => g.draw());
                drawHUD();
            } else {
                drawMap();
                drawPacman();
                ghosts.forEach(g => g.draw());
                drawHUD();
            }

            lastUpdateTime = timestamp;
            gameLoopId = requestAnimationFrame(gameLoop);
        }

        // --- INPUT KEZEL√âS ---

        function handleKeydown(e) {
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                e.preventDefault(); 
            }
            
            if (isPaused) {
                if (e.key === 'Enter') {
                    if (document.getElementById('message-box').style.display === 'block' && document.getElementById('message-text').textContent.includes('ENTER')) {
                        isPaused = false;
                        hideMessage();
                    }
                }
                return;
            }

            // Csak a k√∂vetkez≈ë ir√°nyt √°ll√≠tja be, a t√©nyleges mozg√°s a checkNextDirection-ben d≈ël el
            switch (e.key) {
                case 'ArrowUp':
                case 'w':
                    pacman.nextDirX = 0;
                    pacman.nextDirY = -PAC_SPEED;
                    break;
                case 'ArrowDown':
                case 's':
                    pacman.nextDirX = 0;
                    pacman.nextDirY = PAC_SPEED;
                    break;
                case 'ArrowLeft':
                case 'a':
                    pacman.nextDirX = -PAC_SPEED;
                    pacman.nextDirY = 0;
                    break;
                case 'ArrowRight':
                case 'd':
                    pacman.nextDirX = PAC_SPEED;
                    pacman.nextDirY = 0;
                    break;
                case 'p':
                case 'P':
                    isPaused = !isPaused;
                    if (isPaused) {
                        showMessage('PAUSED', Infinity);
                    } else {
                        hideMessage();
                    }
                    break;
            }
        }

        // --- INICIALIZ√ÅL√ÅS ---
        window.onload = function() {
            document.addEventListener('keydown', handleKeydown);
            showMessage('Press ENTER to Start', Infinity);
            
            pfpImage.onload = () => {
                 gameLoop(0); 
            };
            if (pfpImage.complete) {
                 gameLoop(0); 
            }
        };

    </script>
</body>
</html>
